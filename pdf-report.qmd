---
title: "🎬 Comprehensive Movie Data Analysis"
subtitle: "TMDB Dataset Insights & Trends"
author: "Vineet Sahoo"
date: today
date-format: "MMMM DD, YYYY"
format:
    pdf:
        documentclass: article
        geometry: 
            - margin=0.8in
            - paperwidth=8.5in
            - paperheight=11in
        fontsize: 11pt
        colorlinks: true
        linkcolor: blue
        urlcolor: blue
        citecolor: blue
        include-in-header:
            text: |
                \usepackage{fancyhdr}
                \usepackage{graphicx}
                \usepackage{booktabs}
                \usepackage{longtable}
                \usepackage{array}
                \usepackage{multirow}
                \usepackage{wrapfig}
                \usepackage{float}
                \usepackage{colortbl}
                \usepackage{pdflscape}
                \usepackage{tabu}
                \usepackage{threeparttable}
                \pagestyle{fancy}
                \fancyhf{}
                \fancyhead[L]{\textbf{Movie Data Analysis}}
                \fancyhead[R]{\thepage}
                \fancyfoot[C]{TMDB Dataset Analysis Report}
        toc: true
        toc-depth: 3
        number-sections: true
        fig-cap-location: bottom
        execute:
            echo: false
            warning: false
            message: false
echo: false
warning: false
message: false
---

## Executive Summary

This comprehensive analysis examines movie data from The Movie Database (TMDB), providing insights into industry trends, genre preferences, and audience engagement patterns. The dataset encompasses thousands of films with detailed metadata including ratings, revenue, release dates, and audience metrics.

**Key Findings:**
- Analysis covers movies spanning multiple decades
- Revenue and rating correlations reveal audience preferences  
- Genre distribution shows evolving entertainment trends
- Release patterns indicate industry production cycles

```{python}
#| include: false

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# Set up matplotlib for better PDF output
plt.style.use('seaborn-v0_8')
plt.rcParams['figure.figsize'] = (10, 6)
plt.rcParams['font.size'] = 10
plt.rcParams['axes.titlesize'] = 12
plt.rcParams['axes.labelsize'] = 10
plt.rcParams['xtick.labelsize'] = 9
plt.rcParams['ytick.labelsize'] = 9
plt.rcParams['legend.fontsize'] = 9

# Load and prepare data
df = pd.read_csv("TMDB-Small.csv")
df['release_year'] = pd.to_datetime(df['release_date'], errors='coerce').dt.year
df['primary_genre'] = df['genres'].str.split(',').str[0].str.strip()
df['profit'] = df['revenue'] - df['budget']
df['roi'] = ((df['revenue'] - df['budget']) / df['budget'] * 100).replace([np.inf, -np.inf], np.nan)
df['decade'] = (df['release_year'] // 10) * 10  # Add decade column to main dataframe

# Calculate key statistics
total_movies = len(df)
avg_rating = df['vote_average'].mean()
total_revenue = df['revenue'].sum()
avg_budget = df['budget'].mean()
year_range = f"{int(df['release_year'].min())} - {int(df['release_year'].max())}"
```

## Dataset Overview

```{python}
#| label: tbl-overview
#| tbl-cap: "Dataset Summary Statistics"

# Create overview statistics
overview_stats = pd.DataFrame({
    'Metric': ['Total Movies', 'Average Rating', 'Total Revenue (Billions)', 
               'Average Budget (Millions)', 'Year Range', 'Genres Available'],
    'Value': [
        f"{total_movies:,}",
        f"{avg_rating:.1f}/10",
        f"${total_revenue/1e9:.1f}B",
        f"${avg_budget/1e6:.1f}M",
        year_range,
        f"{df['primary_genre'].nunique()}"
    ]
})

print(overview_stats.to_latex(index=False, escape=False))
```
{{< pagebreak >}}

## Release Year Distribution Analysis

The temporal distribution of movie releases reveals significant insights about industry production patterns and historical trends in cinema.

```{python}
#| fig-cap: "Movie Release Distribution by Year"
#| fig-align: "center"

# Enhanced release year distribution
plt.figure(figsize=(12, 7))

# Filter out invalid years
valid_years = df[(df['release_year'] >= 1900) & (df['release_year'] <= 2025)]
year_counts = valid_years['release_year'].value_counts().sort_index()

# Create the plot
plt.subplot(2, 1, 1)
plt.plot(year_counts.index, year_counts.values, linewidth=2, color='#2E86AB', alpha=0.8)
plt.fill_between(year_counts.index, year_counts.values, alpha=0.3, color='#2E86AB')
plt.title('Movie Releases by Year', fontsize=14, fontweight='bold', pad=20)
plt.xlabel('Release Year')
plt.ylabel('Number of Movies')
plt.grid(True, alpha=0.3)

# Add decade analysis
plt.subplot(2, 1, 2)
decade_counts = valid_years['decade'].value_counts().sort_index()
decade_labels = [f"{int(d)}s" for d in decade_counts.index]

bars = plt.bar(decade_labels, decade_counts.values, color='#A23B72', alpha=0.7, edgecolor='black', linewidth=0.5)
plt.title('Movie Releases by Decade', fontsize=14, fontweight='bold', pad=20)
plt.xlabel('Decade')
plt.ylabel('Number of Movies')
plt.xticks(rotation=45)

# Add value labels on bars
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2., height + 0.01*max(decade_counts),
             f'{int(height)}', ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.show()
```

### Key Observations:

```{python}
#| output: asis

# Calculate insights
peak_year = year_counts.idxmax()
peak_count = year_counts.max()
recent_trend = year_counts.tail(5).mean()
early_trend = year_counts.head(10).mean()

print(f"""
- **Peak Production Year:** {int(peak_year)} with {peak_count} releases
- **Recent 5-Year Average:** {recent_trend:.1f} movies per year
- **Decade with Most Films:** {decade_counts.idxmax():.0f}s with {decade_counts.max()} total releases
- **Production Growth:** {'Increasing' if recent_trend > early_trend else 'Decreasing'} trend in recent years
""")
```

{{< pagebreak >}}

## Genre Analysis & Market Trends

Understanding genre distribution and performance provides crucial insights into audience preferences and market dynamics.

```{python}
#| fig-cap: "Genre Distribution and Performance Analysis"
#| fig-align: "center"

# Enhanced genre analysis
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

# 1. Genre Distribution (Top 10)
top_genres = df['primary_genre'].value_counts().head(10)
ax1.barh(range(len(top_genres)), top_genres.values, color='#F18F01', alpha=0.8)
ax1.set_yticks(range(len(top_genres)))
ax1.set_yticklabels(top_genres.index)
ax1.set_xlabel('Number of Movies')
ax1.set_title('Top 10 Genres by Count', fontweight='bold')
ax1.grid(axis='x', alpha=0.3)

# Add value labels
for i, v in enumerate(top_genres.values):
    ax1.text(v + 0.01*max(top_genres.values), i, str(v), va='center', fontsize=9)

# 2. Average Rating by Genre
genre_ratings = df.groupby('primary_genre')['vote_average'].mean().sort_values(ascending=False).head(10)
bars2 = ax2.bar(range(len(genre_ratings)), genre_ratings.values, color='#C73E1D', alpha=0.8)
ax2.set_xticks(range(len(genre_ratings)))
ax2.set_xticklabels(genre_ratings.index, rotation=45, ha='right')
ax2.set_ylabel('Average Rating')
ax2.set_title('Average Rating by Genre (Top 10)', fontweight='bold')
ax2.grid(axis='y', alpha=0.3)

# Add value labels
for bar in bars2:
    height = bar.get_height()
    ax2.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'{height:.1f}', ha='center', va='bottom', fontsize=9)

# 3. Revenue by Genre (Top 10)
genre_revenue = df.groupby('primary_genre')['revenue'].sum().sort_values(ascending=False).head(10)
genre_revenue_billions = genre_revenue / 1e9
bars3 = ax3.bar(range(len(genre_revenue_billions)), genre_revenue_billions.values, color='#3E92CC', alpha=0.8)
ax3.set_xticks(range(len(genre_revenue_billions)))
ax3.set_xticklabels(genre_revenue_billions.index, rotation=45, ha='right')
ax3.set_ylabel('Total Revenue (Billions $)')
ax3.set_title('Total Revenue by Genre (Top 10)', fontweight='bold')
ax3.grid(axis='y', alpha=0.3)

# Add value labels
for bar in bars3:
    height = bar.get_height()
    ax3.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'${height:.1f}B', ha='center', va='bottom', fontsize=9)

# 4. Vote Count vs Rating by Genre (Scatter)
genre_stats = df.groupby('primary_genre').agg({
    'vote_count': 'mean',
    'vote_average': 'mean',
    'title': 'count'
}).reset_index()
genre_stats = genre_stats[genre_stats['title'] >= 10]  # Filter genres with at least 10 movies

scatter = ax4.scatter(genre_stats['vote_count'], genre_stats['vote_average'], 
                     s=genre_stats['title']*2, alpha=0.6, c=range(len(genre_stats)), cmap='viridis')
ax4.set_xlabel('Average Vote Count')
ax4.set_ylabel('Average Rating')
ax4.set_title('Genre Performance: Popularity vs Quality', fontweight='bold')
ax4.grid(True, alpha=0.3)

# Add labels for top genres
for i, row in genre_stats.iterrows():
    if row['title'] > 50:  # Label only major genres
        ax4.annotate(row['primary_genre'], (row['vote_count'], row['vote_average']), 
                    xytext=(5, 5), textcoords='offset points', fontsize=8, alpha=0.8)

plt.tight_layout()
plt.show()
```

### Genre Performance Insights:

```{python}
#| output: asis

# Calculate genre insights
most_popular_genre = top_genres.index[0]
highest_rated_genre = genre_ratings.index[0]
highest_revenue_genre = genre_revenue.index[0]

# Calculate most prolific genre per decade safely
try:
    decade_genre_counts = df.groupby(['decade', 'primary_genre']).size()
    most_prolific_by_decade = decade_genre_counts.groupby('primary_genre').sum().idxmax()
except:
    most_prolific_by_decade = most_popular_genre

print(f"""
- **Most Produced Genre:** {most_popular_genre} ({top_genres.iloc[0]} movies)
- **Highest Rated Genre:** {highest_rated_genre} (Average: {genre_ratings.iloc[0]:.1f}/10)
- **Highest Revenue Genre:** {highest_revenue_genre} (${genre_revenue.iloc[0]/1e9:.1f}B total)
- **Market Leader:** {most_popular_genre} dominates both quantity and commercial success
""")
```

{{< pagebreak >}}

## Revenue & Budget Analysis

Financial performance metrics reveal important patterns in movie production investments and returns.

```{python}
#| fig-cap: "Financial Performance Analysis"
#| fig-align: "center"

# Enhanced financial analysis
fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

# 1. Budget vs Revenue Scatter
valid_finance = df[(df['budget'] > 0) & (df['revenue'] > 0)]
ax1.scatter(valid_finance['budget']/1e6, valid_finance['revenue']/1e6, alpha=0.6, s=30, color='#2E86AB')
ax1.set_xlabel('Budget (Millions $)')
ax1.set_ylabel('Revenue (Millions $)')
ax1.set_title('Budget vs Revenue Relationship', fontweight='bold')
ax1.grid(True, alpha=0.3)

# Add break-even line
max_val = max(valid_finance['budget'].max(), valid_finance['revenue'].max()) / 1e6
ax1.plot([0, max_val], [0, max_val], 'r--', alpha=0.7, label='Break-even line')
ax1.legend()

# 2. ROI Distribution
valid_roi = df[(df['roi'].notna()) & (df['roi'] > -100) & (df['roi'] < 1000)]
ax2.hist(valid_roi['roi'], bins=50, color='#F18F01', alpha=0.7, edgecolor='black', linewidth=0.5)
ax2.set_xlabel('Return on Investment (%)')
ax2.set_ylabel('Frequency')
ax2.set_title('ROI Distribution', fontweight='bold')
ax2.grid(axis='y', alpha=0.3)
ax2.axvline(valid_roi['roi'].mean(), color='red', linestyle='--', alpha=0.8, label=f'Mean: {valid_roi["roi"].mean():.1f}%')
ax2.legend()

# 3. Budget trends over time
budget_by_year = df[df['budget'] > 0].groupby('release_year')['budget'].mean()
budget_by_year = budget_by_year[(budget_by_year.index >= 1980) & (budget_by_year.index <= 2025)]
ax3.plot(budget_by_year.index, budget_by_year.values/1e6, linewidth=2, color='#A23B72', marker='o', markersize=4)
ax3.set_xlabel('Release Year')
ax3.set_ylabel('Average Budget (Millions $)')
ax3.set_title('Average Movie Budget Trends', fontweight='bold')
ax3.grid(True, alpha=0.3)

# 4. Top Revenue Movies
top_revenue = df.nlargest(10, 'revenue')[['title', 'revenue', 'release_year']]
top_revenue['revenue_billions'] = top_revenue['revenue'] / 1e9
bars4 = ax4.barh(range(len(top_revenue)), top_revenue['revenue_billions'], color='#C73E1D', alpha=0.8)
ax4.set_yticks(range(len(top_revenue)))
ax4.set_yticklabels([f"{title[:20]}..." if len(title) > 20 else title for title in top_revenue['title']])
ax4.set_xlabel('Revenue (Billions $)')
ax4.set_title('Top 10 Highest Grossing Movies', fontweight='bold')
ax4.grid(axis='x', alpha=0.3)

# Add value labels
for i, v in enumerate(top_revenue['revenue_billions']):
    ax4.text(v + 0.01*max(top_revenue['revenue_billions']), i, f'${v:.1f}B', va='center', fontsize=9)

plt.tight_layout()
plt.show()
```

### Financial Performance Summary:

```{python}
#| label: tbl-financial
#| tbl-cap: "Key Financial Metrics"

# Calculate financial statistics
avg_budget_millions = valid_finance['budget'].mean() / 1e6
avg_revenue_millions = valid_finance['revenue'].mean() / 1e6
avg_roi = valid_roi['roi'].mean()
median_roi = valid_roi['roi'].median()
profitable_percentage = (valid_finance['revenue'] > valid_finance['budget']).mean() * 100

financial_stats = pd.DataFrame({
    'Metric': ['Average Budget', 'Average Revenue', 'Average ROI', 'Median ROI', 'Profitable Movies'],
    'Value': [
        f"${avg_budget_millions:.1f}M",
        f"${avg_revenue_millions:.1f}M", 
        f"{avg_roi:.1f}%",
        f"{median_roi:.1f}%",
        f"{profitable_percentage:.1f}%"
    ]
})

print(financial_stats.to_latex(index=False, escape=False))
```

{{< pagebreak >}}

## Audience Engagement & Ratings Analysis

Understanding audience behavior through voting patterns and rating distributions provides insights into viewer preferences and engagement levels.

```{python}
#| fig-cap: "Audience Engagement Analysis"
#| fig-align: "center"

fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(14, 10))

# 1. Rating Distribution
ax1.hist(df['vote_average'], bins=30, color='#2E86AB', alpha=0.7, edgecolor='black', linewidth=0.5)
ax1.set_xlabel('Vote Average')
ax1.set_ylabel('Frequency')
ax1.set_title('Rating Distribution', fontweight='bold')
ax1.grid(axis='y', alpha=0.3)
ax1.axvline(df['vote_average'].mean(), color='red', linestyle='--', alpha=0.8, 
           label=f'Mean: {df["vote_average"].mean():.1f}')
ax1.legend()

# 2. Vote Count vs Rating
high_engagement = df[df['vote_count'] > 100]
ax2.scatter(high_engagement['vote_count'], high_engagement['vote_average'], alpha=0.6, s=20, color='#F18F01')
ax2.set_xlabel('Vote Count')
ax2.set_ylabel('Vote Average')
ax2.set_title('Vote Count vs Rating (High Engagement Movies)', fontweight='bold')
ax2.grid(True, alpha=0.3)

# Add correlation line
if len(high_engagement) > 0:
    z = np.polyfit(high_engagement['vote_count'], high_engagement['vote_average'], 1)
    p = np.poly1d(z)
    ax2.plot(high_engagement['vote_count'], p(high_engagement['vote_count']), "r--", alpha=0.8)

# 3. Rating by Runtime
runtime_bins = pd.cut(df['runtime'], bins=5, labels=['Very Short', 'Short', 'Medium', 'Long', 'Very Long'])
rating_by_runtime = df.groupby(runtime_bins)['vote_average'].mean()
bars3 = ax3.bar(range(len(rating_by_runtime)), rating_by_runtime.values, color='#A23B72', alpha=0.8)
ax3.set_xticks(range(len(rating_by_runtime)))
ax3.set_xticklabels(rating_by_runtime.index, rotation=45)
ax3.set_ylabel('Average Rating')
ax3.set_title('Rating by Movie Runtime', fontweight='bold')
ax3.grid(axis='y', alpha=0.3)

# Add value labels
for bar in bars3:
    height = bar.get_height()
    ax3.text(bar.get_x() + bar.get_width()/2., height + 0.01,
             f'{height:.1f}', ha='center', va='bottom', fontsize=9)

# 4. Top Rated Movies (minimum 500 votes)
popular_movies = df[df['vote_count'] >= 500]
top_rated = popular_movies.nlargest(10, 'vote_average')[['title', 'vote_average', 'vote_count']]
bars4 = ax4.barh(range(len(top_rated)), top_rated['vote_average'], color='#C73E1D', alpha=0.8)
ax4.set_yticks(range(len(top_rated)))
ax4.set_yticklabels([f"{title[:25]}..." if len(title) > 25 else title for title in top_rated['title']])
ax4.set_xlabel('Vote Average')
ax4.set_title('Top 10 Highest Rated Movies (500+ votes)', fontweight='bold')
ax4.grid(axis='x', alpha=0.3)

# Add value labels
for i, v in enumerate(top_rated['vote_average']):
    ax4.text(v + 0.01*max(top_rated['vote_average']), i, f'{v:.1f}', va='center', fontsize=9)

plt.tight_layout()
plt.show()
```

### Audience Insights:

```{python}
#| output: asis

# Calculate audience insights
avg_rating = df['vote_average'].mean()
avg_votes = df['vote_count'].mean()
highly_rated_threshold = 8.0
highly_rated_count = (df['vote_average'] >= highly_rated_threshold).sum()
most_voted_movie = df.loc[df['vote_count'].idxmax()]

print(f"""
- **Average Movie Rating:** {avg_rating:.1f}/10 across all films
- **Average Vote Count:** {avg_votes:,.0f} votes per movie
- **Highly Rated Films:** {highly_rated_count} movies rated {highly_rated_threshold}+ stars
- **Most Voted Movie:** "{most_voted_movie['title']}" with {most_voted_movie['vote_count']:,} votes
- **Rating Correlation:** {'Positive' if high_engagement['vote_count'].corr(high_engagement['vote_average']) > 0 else 'Negative'} correlation between popularity and rating
""")
```

{{< pagebreak >}}

## Featured Movie Spotlight

```{python}
#| output: asis

# Select a high-quality movie for spotlight
featured_movies = df[(df['vote_average'] >= 8.0) & (df['vote_count'] >= 1000)]
if len(featured_movies) > 0:
    featured = featured_movies.sample(1).iloc[0]
else:
    featured = df.sample(1).iloc[0]

# Format featured movie details
title = featured['title']
year = int(featured['release_year']) if pd.notna(featured['release_year']) else 'N/A'
rating = featured['vote_average']
votes = int(featured['vote_count'])
runtime = int(featured['runtime']) if pd.notna(featured['runtime']) else 'N/A'
budget = f"${featured['budget']/1e6:.1f}M" if featured['budget'] > 0 else 'N/A'
revenue = f"${featured['revenue']/1e6:.1f}M" if featured['revenue'] > 0 else 'N/A'
genre = featured['primary_genre']
overview = featured['overview'] if pd.notna(featured['overview']) else 'No description available.'

print(f"""
### 🌟 {title} ({year})

**Genre:** {genre} | **Rating:** ⭐ {rating}/10 | **Votes:** {votes:,} | **Runtime:** {runtime} min

**Financial Performance:**
- Budget: {budget}
- Revenue: {revenue}
""")

if featured['revenue'] > 0 and featured['budget'] > 0:
    profit = (featured['revenue'] - featured['budget']) / 1e6
    roi = ((featured['revenue'] - featured['budget']) / featured['budget']) * 100
    print(f"- Profit: ${profit:.1f}M")
    print(f"- ROI: {roi:.1f}%")

print(f"""

**Synopsis:**
{overview}

---
""")
```

## Key Findings & Conclusions

Based on our comprehensive analysis of the TMDB movie dataset, several important trends and insights emerge:

### 📈 Industry Trends

```{python}
#| output: asis

# Calculate final insights for conclusion
recent_movies = df[df['release_year'] >= 2010]
classic_movies = df[df['release_year'] < 1990]

recent_avg_budget = recent_movies['budget'].mean() / 1e6
recent_avg_rating = recent_movies['vote_average'].mean()
classic_avg_rating = classic_movies['vote_average'].mean()

most_profitable_genre = df.groupby('primary_genre')['profit'].mean().idxmax()
highest_roi_movie = df.loc[df['roi'].idxmax()] if df['roi'].max() > 0 else None

print(f"""
1. **Production Evolution:** Modern films (2010+) have an average budget of ${recent_avg_budget:.1f}M, reflecting industry growth and inflation.

2. **Quality Consistency:** Recent movies maintain high quality standards with an average rating of {recent_avg_rating:.1f}/10, comparable to classics ({classic_avg_rating:.1f}/10).

3. **Genre Profitability:** {most_profitable_genre} shows the highest average profit margins, indicating strong commercial viability.

4. **Audience Engagement:** Higher vote counts generally correlate with better ratings, suggesting engaged audiences appreciate quality content.
""")

if highest_roi_movie is not None:
    print(f"""
5. **Investment Success:** "{highest_roi_movie['title']}" achieved the highest ROI at {highest_roi_movie['roi']:.1f}%, demonstrating exceptional financial performance.
""")
```

### 🎯 Strategic Recommendations

Based on the data analysis, the following strategic insights emerge for industry stakeholders:

- **Genre Strategy:** Focus on consistently profitable genres while exploring innovative storytelling within established frameworks
- **Budget Optimization:** Balance production costs with revenue potential, as higher budgets don't always guarantee higher returns
- **Audience Engagement:** Prioritize quality storytelling to achieve both critical acclaim and commercial success
- **Market Timing:** Consider seasonal release patterns and industry production cycles for optimal market positioning

### 📊 Dataset Limitations

This analysis is based on available TMDB data and may not represent the complete global film industry. Future analyses could benefit from:
- International box office data inclusion
- Streaming platform performance metrics  
- Social media engagement correlations
- Production company performance analysis

---

*This report was generated on `{python} datetime.now().strftime('%B %d, %Y')` using comprehensive movie data analysis techniques. For questions or additional insights, please contact the analysis team.*

**Report Statistics:**
- Total movies analyzed: `{python} f"{len(df):,}"`
- Analysis period: `{python} year_range`
- Genres covered: `{python} df['primary_genre'].nunique()`
- Data completeness: `{python} f"{(1 - df.isnull().sum().sum() / (len(df) * len(df.columns))) * 100:.1f}%"`